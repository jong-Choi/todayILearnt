# CT

---

---

## 0. Intro

- ‘컴퓨터 사고력’ 과정은 컴퓨터 공학에서 ‘이산 수학’에 해당
- 이산 수학 (Discrete Mathematics)의 의미와 활용
    - Discrete : (형) 별개의, 분리된 = ‘연속적이지 않은’의 의미
        - 컴퓨터는 연속적이지 않은, 이산적인 개념을 처리
        → 현실의 연속적인 문제를 추상화 및 모델링해서 접근하기 위한 수학적 접근법
        - 이산적 = 논리, 집합 ...
        - 연속적 = 미분, 적분 ...
    - 우리는 이산 수학을 배운적이 있다.
        - 그림 예시 (고등학교 기준, 수학의 분류)
            
            ![Untitled](CT%2097218e058a9f463d80186f73a8a51ad8/Untitled.png)
            
    - 이산 수학의 분야 및 응용
        - 이산 수학 분야(목차)
            - 집합, 명제, 논리, 확률, 함수, 행렬, 트리/그래프, 형식 언어 ...
        - 이산 수학 응용
            - 논리 → 모든 프로그래밍
            - 집합, 논리, 명제, 확률 → 인공 지능, 기계 학습
            - 행렬 → 영상 처리, 컴퓨터 그래픽스, 기계 학습
            - 트리, 그래프 → 자료구조, 알고리즘
    - 컴퓨터 공학에서 이산 수학이 관련된 과목
        
        이산 수학 
        
        → 자료구조 → 알고리즘
        
        → 운영체제
        
        → 선형대수학
        
        → 컴퓨터 구조
        
        → 인공지능 
        
        ...
        
    - IT 업계 종사자의 이산 수학
        
        (1)현실 문제 → (2)모델 → (3)해답
        
        - (1) → (2) : 모델링
        - (2) → (3) : 구현
        - (2)모델에서 이산 수학을 사용

### 명제(proposition)와 논리(logic)

- 명제란?
    
    참과 거짓을 객관적이고 명확하게 구분할 수 있는 식이나 문장
    
    - 통상 영문 소문자 p, q, r, ... 등으로 표기
    - 명제가 참 또는 거짓의 값을 가질 때, 그 값을 명제의 진리값(truth value)라 함
    - 명제는 True, False 2가지의 진리값을 가지므로 이진 논리라함
- 논리란?
    
    참과 거짓을 판별하는 법칙
    
    - 명제 논리(Propositional Logic)
        - 주어와 술어를 구분하지 않고, 전체를 하나의 식으로 처리하여 참과 거짓을 판별
        - 명제를 가지고 논리는 판별하는 것
    - 술어 논리(Predicate Logic)
        - 주어와 술어로 구분하여 참 또는 거짓을 판별하는 법칙
        - ~이면 ~이다

### 논리 연산자

- 논리 연산자란?
    - 단순 명제를 연결시켜주는 연산자
    - 종류
        - 부정(not): ~ 또는 $\lnot$
        - 논리합(or) : $\lor$
        - 논리곱(and) : $\land$
        - 배타적 논리합 (exclusive or) : $\oplus$
        - 조건 (condition) : →
        - 쌍방조건(bicondition) : $\leftrightarrow$
        - 그 외 (nand, nor ...)
- 진리표(truth table) 란?
    
    합성 명제를 구성하는 모든 명제들의 진리값이 가능한 경우를 모두 나열한 표
    
    | p | q | p ⁍ q |
    | --- | --- | --- |
    | T | T | T |
    | T | F | F |
    | F | T | F |
    | F | F | F |

### 조건명제

- 조건이 거짓이면 결론은 항상 참이다
    - 거짓을 가정하고 시작하면 결론은 항상 참
    - 예시
        
        “너가 다이어트 성공하면 내가 백두산 기어서 올라간다” 
        
        - 말하는 사람 입장에서 보면 가정이 거짓(다이어트에 성공할리 없다고 생각)이므로
        항상 완벽하게 참인 명제가 된다.
        - ‘아, 논리학에서 모순을 피하기 위해 선택한 방법이구나!’ 정도로 알고 넘어가기.

### 증명(Proof)

- 증명이란?
    - 논리적 법칙을 이용하여 주어진 가정으로부터 결론을 유도해내는 추론의 한 방법
    - 어떤 명제나 논증이 적절하고 타당한지 입증하는 방법
- 연역법(deduction)
    - 주어진 사실과 공리들로부터 추론을 이용해서  새로운 사실을 도출하는 방법
        - fact 1 : 홍길동은 사람이다.
        - fact 2 : 사람은 죽는다.
        - 새로운 사실 : 홍길동도 죽는다.
- 귀납법 (induction)
    - 관찰과 실험에 기반한 가설에 대해서 추론을 적용해서 일반적인 규칙을 입증하는 방법
        - 관찰 1 : A는 죽었다.
        - 관찰 2 : B는 죽었다.
        - 관찰 3 : C는 죽었다.
        - 일반적인 규칙 : 사람은 죽는다.
- 수학적 귀납법 (mathmetical induction)
    - 수학적 귀납법이란?
        - $n$이 $n_0$인 경우에 성립함을 보이고, n이 k인 경우에 성립함을 가정한 다음,
        n이 k+1일때 성립함을 보임으로써 모든 자연수에 대해서 성립함을 보이는 방법
            - 기초 (induction basis)
                - $n$이 $n_0$인 경우에 성립함을 증명
            - 가정 (induction hypothesis)
                - n이 k일 때 성립함을 가정
            - 단계 (induction step)
                - 가정을 이용해서 n이 k+1일 때 성립함을 증명
    - 예시 (포화 이진 트리의 노드 수)
        - 포화 이진 트리의 루트를 1세대라고하고, 자식의 세대는 부모의 세대 +1이라면 n 번째 세대에는 $2^{n-1}$개의 노드가 존재함을 증명해라.
        - 증명
            - 기초
                
                n=1 일 때, $2^{1-1}=2^0=1$ 루트는 1개 
                
            - 가정
                
                n=k 일 때, $2^{k-1}$개의 노드가 존재 
                
            - 단계
                - n = k일 때 참임을 가정하면 n = k+1일때도 참이므로, 수학적 귀납법에 의해 참이다
                따라서 n번째 세대에는  $2^{n-1}$개의 노드가 존재한다
                - n=k+1 이라면, k번째 세대에서 모든 노드가 2개씩의 자식 노드를 가진 상태이기 때문에, k번째 세대의 노드 수인 $2^{k-1}$이 2명의 자식 노드를 갖는다고 하면 
                $2^{k-1} * 2 = 2^k$ 명이 존재한다. 따라서 n번째 세대에는  $2^{n-1}$개의 노드가 존재한다
- 모순 증명법 (proof by contradictoin)
    - p가 참이고 p → q가 참이라면, q도 참이다 (긍정 법칙)
    - q가 거짓이라고 가정하면, p → q가 참이 되기 위해서는 p도 거짓이어야 한다.
    - 따라서, p를 참이라고 설정한 가정에 대해서 모순이 발생.
    - 모순이 발생한 원인은 q를 거짓이라고 했기 때문이므로, 따라서 q는 참.
    - 따라서 p → q도 참이다.
    
- 기타
    - 직접 증명법 (direct proof)
    - 대우 증명법 (contrapositive proof)
    - 존재 증명법 (existence proof)
    - 반례 증명법 (proof by counter-example)
    - 필요충분조건 증명법 (if and only if proof)

---

## 1. 논리와 증명

- 1. 다음 명제들이 항진명제라는 것을 진리표를 이용해서 보이시오
    
    ### 1.1 ~(~𝑝∧𝑞)∨𝑞
    
    | p | q | ~p | (~p ∧ q) | ~(~p∧q) | ~(~p∧q) ∨ q |
    | --- | --- | --- | --- | --- | --- |
    | T | T | F | F | T | T |
    | T | F | F | F | T | T |
    | F | T | T | T | F | T |
    | F | F | T | F | T | T |
    
    ### 1.2 (~p∨q)∨(p∧~q)
    
    | p | q | ~p | (~p ∨ q) | ~q | (p ∧ ~q) | (~p ∨ q ) ∨ (p ∧ ~q) |
    | --- | --- | --- | --- | --- | --- | --- |
    | T | T | F | T | F | F | T |
    | T | F | F | F | T | T | T |
    | F | T | T | T | F | F |  |
    | F | F | T | T | T | F | T |
- 2. 다음 명제들이 모순명제라는 것을 진리표를 이용해서 보이시오
    
    ### 2.1 (~p∨q)∧(p∧~q)
    
    | p | q | ~p | (~p∨q) | ~q | (p∧~q) | (~p∨q)∧(p∧~q) |
    | --- | --- | --- | --- | --- | --- | --- |
    | T | T | F | T | F | F | F |
    | T | F | F | F | T | T | F |
    | F | T | T | T | F | F | F |
    | F | F | T | T | T | F | F |
    
    ### 2.2 (p∧q)∧(p∧~q)
    
    | p | q | ~q | (p∧q) | (p∧~q) | (p∧q)∧(p∧~q) |
    | --- | --- | --- | --- | --- | --- |
    | T | T | F | T | F | F |
    | T | F | T | F | T | F |
    | F | T | F | F | F | F |
    | F | F | T | F | F | F |
- 3. 다음 명제의 쌍 들에 대해서 두 명제가 동등한지를 진리표를 이용해 확인하시오
    
    ### 3.1 p∧(p∨q)와 p
    
    | p | q | (p∨q) | p∧(p∨q) |
    | --- | --- | --- | --- |
    | T | T | T | T |
    | T | F | T | T |
    | F | T | T | F |
    | F | F | F | F |
    
    ### 3.2 ~p∨~q와 ~(p∨q)
    
    | p | q | ~p | ~q | ~p∨~q | (p∨q) | ~(p∨q) |
    | --- | --- | --- | --- | --- | --- | --- |
    | T | T | F | F | F | T | F |
    | T | F | F | T | T | T | F |
    | F | T | T | F | T | T | F |
    | F | F | T | T | T | F | T |
- 9. (대우를 증명) 자연수 𝑛에 대해, $𝑛^2+5$가 홀수이면 𝑛은 짝수임을 증명하라
    
    (힌트: 명제 대신, 𝑛이 홀수이면 𝑛^2+5은 짝수임을 증명한다)
    
    **증명**
    
    대우 명제 : n이 홀수이면 n^2+5은 짝수이다
    n = 2k + 1 라고 하자(k는 어떤 실수)
    
    n^2+5
    
    = (2k+1)^2+5
    
    = 4k^2+4k+6
    
    = 2(2k^2+2k+3)
    따라서 n이 홀수이면 n^2+5은 짝수이다.
    대우 명제가 참이므로, 본 명제 또한 참이다.
    
- 10. $𝑛^2$이 짝수이면 𝑛은 짝수임을 증명하라.
    
    **증명**
    
    대우 명제 : n이 홀수이면 n^2이 홀수이다.
    n = 2k + 1 라고 하자(k는 어떤 실수)
    
    n^2
    
    =(2k+1)^2
    
    =4k^2+4k+1
    
    =2(2k^2+2k)+1
    따라서 n이 홀수이면 n^2은 홀수이다.
    대우 명제가 참이므로, 본 명제 또한 참이다.
    
- 11. (경우를 나누어 증명) 자연수 𝑛에 대해 $`𝑛^2+5𝑛+3`$은 항상 홀수임을 증명하라.
    
    (힌트: n이 짝수인 경우와 홀수인 경우를 따로 증명한다)
    
    **증명**
    
    - n이 짝수인 경우
    n = 2k 라고 하자(k는 어떤 실수)
        
        n^2+5n+3
        
        = (2k)^2+5(2k)+3
        
        =4k^2+10k+3
        
        =2(2k^2+5k+1)+1
        따라서 n이 짝수이면 n^2+5n+3은 홀수이다.
        
    
    - n이 홀수인 경우
    n = 2k+1 라고 하자(k는 어떤 실수)
        
        n^2+5n+3
        
        = (2k+1)^2+5(2k+1)+3
        
        =4k^2+14k+9
        
        =2(2k^2+7k+4)+1
        따라서 n이 홀수이면 n^2+5n+3은 홀수이다.
        
    - n이 짝수인 경우와 홀수인 경우 모두 n^2+5n+3은 항상 홀수이므로
        
        자연수 n에 대해 n^2+5n+3은 항상 홀수이다.
        
- 12. $𝑛^2$이 3의 배수이면 𝑛은 3의 배수임을 증명하라.
    
    **증명**
    
    대우 명제 : n이 3의 배수가 아니면 n^2은 3의 배수가 아니다.
    
    - n을 3으로 나눈 나머지가 1일 때
        
        n=3k+1라고 하자(k는 어떤 실수)
        
        $n^2$
        
        $=(3k+1)^2$
        
        $=9k^2+6k+1$
        
        $=3(3k^2+2k)+1$ 이므로 3의 배수가 아니다.
        
    - n을 3으로 나눈 나머지가 2일 때
        
        n=3k+2일 때
        
        $n^2$
        
        $=(3k+2)^2$
        
        $=9k^2+12k+4$
        
        $=3(3k^2+4k+1)+1$ 이므로 3의 배수가 아니다.
        
    - 따라서 n이 3의 배수가 아니면 $n^2$은 3의 배수가 아니다.
    대우 명제가 참이므로, 본 명제 또한 참이다.

---

## 2. 수와 표현

- 1. 2진수 표현에서 $log⁡n$ 비트로 표현할 수 있는 숫자 범위는?
    
    n비트로 표현할 수 있는 숫자는 2^n가지의 값이 있다.
    log(⁡n) 비트로 표현할 수 있는 숫자는 n가지의 값이 있다.
    
    ↔
    
    k개의 비트로 2^k개 표현 가능
    
    let k = log(n)
    
    2^k = 2^(log(n)) = n
    
    따라서 log(n)개의 비트로 n개 표현 가능
    
- 2. 스무고개가 이상적으로 진행된다고 할 때, 맞출 수 있는 답의 종류는 몇 가지인가?
    
    2^20= 1048576 가지
    라고 되어있지만, “맞출 수 있는 답의 종류”라는 워딩이 맘에 들진 않는다.
    
    → 20개의 항목에 대해 1048576 가지의 서로 다른 군집(모임, cluster)이 존재한다.
    내가 2고개를 진행한다고 했을 때, 맞출 수 있는 답의 종류가 4개이다 라는게 말이 되는가? 
    4개의 서로 다른 군집이 존재하는 것이다.
    
- 3. 𝑛이 충분히 큰 값일 때 다음 중 어느 값이 더 큰가? 각 쌍에 대해 비교하고 그 이유를 작성하시오.
    
    ↔ 는 대소관계를 모르는 상황에서 둘을 좌항, 우항에 넣고 비교를 한다라는 의미로 사용하였습니다.
    
    ### 3.1   2n  (   )  n^2
    
    **<**
    
    let k = n^2-2n
    
    k 
    
    = n^2-2n
    
    = (n-1)^2 - 1
    
    > 0             for 충분히 큰 n (2>n)
    
    → n^2 - 2n > 0
    
    → 2n < n^2
    
    따라서 부등호 방향은 **<**
    
    ### 3.2  2^(n/2) (  )  √(3^n )
    **<**
    
    2^(n/2) ↔ 3^(n/2)
    
    → 양변에 로그를 씌워줌 (log는 1 이상일 때 단조증가 함수여서 충분히 큰 n에 대해 양변에 로그를 씌워줘도 대소관계가 변하지 않음)
    
    n/2 * log(2) ↔ n/2 * log(3)
    
    이때 충분히 큰 n(n>0)에 대해 우항이 항상 크다.
    
    따라서 부등호 방향은 <
    
    ### 3.3 2^(n log⁡n )  (   )  n!
    
    **>**
    
    2^(n log⁡n ) ↔ n!
    
    → 양변에 로그를 씌워줌
    
    nlog(n)*log(2) ↔ log(n!) = log(1) + log(2) + ... + log(n)
    좌항은 log(n)이 n개 있고, 우항은 log(k)가 1부터 증가하면서 n까지 총 n개가 있다.
    
    따라서 충분히 큰 n에 대해 우항이 항상 크다.
    
    따라서 부등호 방향은 <
    
    ### 3.4 log(2^2n)  (   )  n√n
    
    **<**
    
    log(2^2n) ↔  n√n
    
    2n ↔ n*n^(1/2)
    
    2 ↔ n^(1/2)
    
    충분히 큰 n에 대해 우항이 항상 크다.
    
    따라서 부등호 방향은 <
    
- 4.  $x=log_a(yz)$ 일 때 𝑥를 2를 밑으로 하는 로그들로 표현하시오. 
단, 로그 함수의 인자는 모두 문자 하나여야 한다.
    - 로그 함수의 성질
        
        ![Untitled](CT%2097218e058a9f463d80186f73a8a51ad8/Untitled%201.png)
        
    
    $$
    \begin{equation} 
    \begin{split}
    
    x & = log_ayz\\ &
    = \frac{log_2yz}{log_2a}  \quad 밑\space 변환\space법칙\\&
    = \frac{log_2y + log_2z}{log_2a} \quad 덧셈\space법칙\\
    \end{split}
    \end{equation} 
    
    $$
    

---

## 3. 집합과 조합론

**조합**

- n개 중 r개를 뽑는 방법의 수

$$
\binom{n}{r} = nCr = \frac{n!}{(n-k)!k!}
$$

- 문제 1. 다음을 증명하라
    
    $$
    
    \binom{n}{k} + \binom{n}{k-1} = \binom{n+1}{k}
    $$
    
    - **증명**
        
        ![Untitled.png](CT%2097218e058a9f463d80186f73a8a51ad8/Untitled%202.png)
        
- 문제 2. 수학적 귀납법으로 다음을 증명하라
    
    $$
    (x+y)^n = \sum_{k=0}^n\binom{n}{k}x^{n-k}y^k
    
    $$
    
    - **증명**
        
        ![Untitled](CT%2097218e058a9f463d80186f73a8a51ad8/Untitled%203.png)
        
        ![Untitled](CT%2097218e058a9f463d80186f73a8a51ad8/Untitled%204.png)
        
- 문제 8. 8×8 체스 판에 말 두개를 놓으려고 한다. 아무 곳에나 놓아도 되지만 한 칸에 두개가 들어가지는 못한다. 가능한 방법은 모두 몇가지인가?
    - 풀이
        
        8×8 체스 판 중에서 두 곳을 고르는 조합을 구하는 문제이므로,
        ($64C2$)= 2,016
        
        모두 2,016개가 존재한다.
        
        $$
        \binom{64}{2} = \frac{64*63}{2!} = 2016
        $$
        
    
- 문제 10. 비밀번호를 0부터 9까지의 숫자만 가지고 만든다고 하자. 4개 이상 6개 이하의 숫자를 쓸 수 있다고 할 때 가능한 비밀번호의 가지수는 얼마인가?
    - 풀이
        
        가능한 비밀번호는 숫자가 4개, 5개, 6개가 들어갈 경우이다.
        숫자가 4개 사용될 경우 : 10 × 9 × 8 × 7=5,040
        숫자가 5개 사용될 경우 : 10 × 9 × 8 × 7 × 6=30,240
        숫자가 6개 사용될 경우 : 10 × 9 × 8 × 7 × 6 × 5=151,200
         
        따라서 총 가능한 비밀번호의 가지 수는 186,480개 이다.
        
    
- 문제 12. 52개의 카드를 이용해서 만들 수 있는 5개 카드의 조합은 몇가지인가?
    - 풀이
        
        $$
        \binom{52}{5} = \frac{52 * 51 * 50 * 49 * 48}{5 * 4 * 3 * 2 * 1} = 2598960
        $$
        
    
- 문제 16. 52개 카드에서 5개 카드 조합을 만들 때, 숫자가 같은 카드가 한 쌍도 없는 경우는 몇 가지인가?
    - 풀이
        
        정답은 `1,317,888` 
        (1) 52C1  -  1장 고르고,
        (2) 48C1  -  (1)과 같은 숫자 4장 빼고 1장고르고
        (3) 44C1
        (4) 40C1
        (5) 36C1
        답 : (1)*(2)***(3)*(4)*(5) /  5!   - /5! : 고른 순서에 의해 구분되는 경우 제거
        

---

## 4. 기초 수식

### 시간복잡도 Big O 특징

1. 복잡도의 점근적 상한을 나타낸다.
2. 복잡도 다항식의 최고차항만 계수 없이 취하면 된다.
    1. 상수 항은 무시
        - $`O(2N)`$ or $`O(N/2)`$ -> $`O(N)`$
    2. 영향
        - $`O(N^2 + 2N + 1)`$ -> $`O(N^2)`$

**다음 재귀식들을 $`O()`$ notation 수준으로 풀어라.**

- 계산방식
    1. T(n)에 관한 식을 정리하여 k에 관하여 일반화한다.
    2. 그럼 T(x)안의 x는 n, k에 관한 관계식이 된다.
    3. 이 이 관계식을 적당한 상수로 생각하여 진행한다.
        1. ex) 정리한 관계식이 `T(${n/2^k}$)` 라고 할 때, 
            
            ${n/2^k} = 1$
            
            $n = 2^k$
            
        
        그렇다면, 이렇게 해도 괜찮나...?
        
    4. k에 관하여 일반화된 식에 대입하여 n에 대한 식으로 정리한 후 O()를 씌운다.
- (들어가기전에) T(n) : f(n)에 의한 연산의 횟수, T(0) = 1
    
    (문제에 따라 n에 독립적인 계산들 T(k)들은 1로 계산 즉, T(0) = 1 or T(1) = 1 or T(2) = 1 등...)
    
- 문제 1. $`𝑇(𝑛)=𝑇(𝑛−1)+1`$
    
    $$
    \begin{equation*}
    \begin{split}
    &T(n)\\&
    =T(n-1) + 1\\&
    = { T(n-2) + 1 } + 1 = T(n-2) + 2        \qquad ← T(n)에 n-1 대입, T(n-1) = T(n-2) + 1\\&
    = T(n-k) + k\\&
    let n = k, then\\&
    T(0) + n\\&
    = n+1\\&
    
    \end{split}
    \end{equation*}
    $$
    
    따라서 T(n) = n+1 = O(n)
    
- 문제 2. $`𝑇(𝑛)=𝑇(𝑛−1)+𝑛`$
    
    T(n)
    
    = T(n-1) + n
    
    = {T(n-2) + n-1 } + n          ← T(n)에 n-1 대입, T(n-1) = T(n-2) + n-1
    
    = T(n-k) + (n- (k-1)) + n-(k-2) + ... + n
    
    let k = n, then
    
    T(0) + 1 + 2 + ... + n
    
    = 1 + n(n-1)/2
    
    따라서 T(n) = 1 + n(n-1)/2 = O(n^2)
    

---

## 5. 재귀

다음 문제들을 푸는 재귀 알고리즘을 수도코드로 작성하고, 정확성 증명 및 시간 복잡도 계산을 수행하라

- 문제 1. 피보나치 수열: $`F(n)=F(n-1)+F(n-2), F(1)=F(2)=1`$
    - **수도코드**
        
        ```python
        def fibo(n -> natural number):
        		if n == 1 or n == 2:
        				return 1
        		return fibo(n-1) + fibo(n-2)
        ```
        
    - **시간복잡도**
        
        수도코드의 재귀에서, fibo(n)은 f(n-1), f(n-2) 그리고 그들의 합연산 1 만큼의 복잡도가 든다.
        
        → T(n) = T(n-1) + T(n-2) + 1
        
        T(n) 
        = T(n-1) + T(n-2) + 1
        
        <T(n-1) + T(n-1) + 1
        
        = 2T(n-1) +1
        
        = 2^2T(n-2) + 2 + 1
        
        = 2^kT(n-k) + 2^(k-1) + 2^(k-2) + ... + 1
        
        let k = n -1, then
        
        2^kT(n-k) + 2^(k-1) + 2^(k-2) + ... + 1
        
        = 2^(n-1)T(1) + 2^(n-2) + ... + 1
        
        = 2^(n-1)T(1) + 2^(n-1)- 1 
        
        = 2^n - 1
        
        따라서 T(n) = O(2^n)
        
    
- 문제 2. Merge Sort
    - 머지소트 컨셉
        - Merge Sort, 크기 𝑛인 배열을 입력으로 받아,
        배열을 절반으로 두개로 나눈 후,
        각 작은 배열을 재귀적으로 정렬하고,
        그 결과를 Merge한다.
    - **수도코드**
        - 인덱스 정확하지 않습니다
        
        ```python
        def merge(lst, start, end):
        		if start == end :
        				return
        		mid = (start + end) // 2
        
        		merge(lst, start, mid)
        		merge(lst, mid+1, end)
        
        		ans = []
        		i = start
        		j = mid +1
        		while i to mid, j to end:
        				if lst[i] < lst[j]:
        						ans.append(i)
        				else:
        						ans.append(j)
        		lst = ans
        ```
        
    - **시간복잡도**
        
        수도코드의 재귀에서, merge(n)은 merge(n//2) 2번,  그리고 그들을 합하는 n 만큼의 복잡도가 든다.
        
        → T(n) = 2T(n/2) + n
        
        T(n)
        
        = 2T(n/2) + n
        
        = 2(2T(n/2^2) + n/2) + n
        
        = 2^2T(n/2^2) + 2n
        
        = 2^2(2T(n/2^3)+ n/2^2) + 2n
        
        = 2^3T(n/2^3) + 3n
        
        = 2^kT(n/2^k) + kn
        
        let 2^k = n (k = log(n)), then
        
        2^kT(n/2^k) + kn 
        
        = nT(1) + nlog(n)
        
        따라서, T(n) = O(nlog(n))
        
    

---

## 6. 동적 프로그래밍

**상향식**

- 타뷸레이션
    - 데이터를 테이블 형태로 만들면서 문제를 풀이한다고 하는 의미
- 더 작은 하위 문제부터 살펴본 다음, 작은문제의 정답을 이용해 큰 문제의 정답을 만들어 풀어나감
- 일반적으로 이 방식만을 동적 프로그래밍으로 지칭하기도 함

**하향식**

- 메모이제이션
    - 기존 재귀 풀이와 거의 동일하면서도 이미 풀어봤는지 확인하여 재활용하는 효율적인 방식
- 하위 문제에 대한 정답을 계산했는지 확인해가며 문제를 자연스러운 방식으로 풀어나감

다음 문제들을 푸는 동적 프로그래밍 알고리즘을 수도코드로 작성하고, 
정확성 증명 및 시간 복잡도 계산을 수행하라

- 문제 1. Memoization 피보나치 수열
    
    **하향식**
    
    - (**수도)코드**
        
        ```python
        def fibo(n):
            if n < 2:
                return n
            if lst[n]:
                return lst[n]
            lst[n] = fibo(n-1) + fibo(n-2)
            return lst[n]
        
        n = 6
        lst = [0] * (n+1)
        ```
        
    - **시간복잡도**
        - $`O(n)`$
    
- 문제 2. Dynamic Programming 피보나치 수열
    
    **상향식**
    
    - (**수도)코드**
        
        ```python
        def fibo(n):
        		lst  = [1, 1]
        		if n < 2:
        				return lst[n]
        		while len(lst) < n:
        				lst.append(lst[-1] + lst[-2])
        		return lst[-1]
        ```
        
    - **시간복잡도**
        - $`O(n)`$