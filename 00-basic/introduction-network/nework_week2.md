# 컴퓨터 네트워크 (한양대학교 이석복 교수님)


## 5강 전송계층 1

### RDT3.0 모델의 효율문제
전체 시간 중에 네트웍을 사용하는 시간이 클 수록 네트워크의 효율이 좋다.  

![ㅁㄴㅇ](,,/../../../src/network3-39.PNG)
패킷을 하나 전송하고 하나 피드백 하나를 받는 모델의 경우, 패킷을 보내고 기다리는 시간이 길다. 
U(Utilization)을 구해보면, (패킷의 길이/패킷을 전송하는데 걸리는 속도) / 패킷을 하나 보내고 나서 대기하는 속도+(패킷의 길이/패킷을 전송하는데 걸리는 속도)  = 0.027 수준.  
  
### 네트워크 효율 개선방안 : 파이프라인 전송
패킷을 한 번에 여러개 보내면 Utilization이 증가한다. 

**파이프 라인 전송의 접근법 : GBn, SR**
- 파이프라인 두가지 일반적인 접근방법 - go-Back-N, selective repeat.

### go-Back-N 방식
- 한 번에 많은 패킷을 발송한다.   
- 패킷의 갯수를 정하는 기준 - window size.  
가령 winodow size가 4라면 0,1,2,3를 보낸다.    
ACK는 cumulative ACK이다. ACK #11은 11번까지 받았다는 의미.  
- Sender는 각 패킷에 대한 타이머를 가진다.  
1번 패킷이 Time Out되면 1, 2, 3을 모두 재전송한다.  

**GBN 모델에서의 Sender의 행동 FSM**
![ㅁㄴㅇ](,,/../../../src/network3-44.PNG)  
- Window Size 설정,
- **전송**: Window Size만큼 #base, #base+1, ... , #base+windowSize-1 만큼 전송, 타이머 작동. 
- **추가전송**: 전송이 끝나면 #base+windowSize부터 추가로 전송, 타이머 작동 <br>
- **Time Out** : #base를 Time Out이 발생한 시퀀스 번호로 하여 windowSize만큼 재전송  

**GBN 모델에서의 RECEIVER의 행동 FSM**
RECEIVER의 행동은 상대적으로 단순하다.   

- ACK#i에 대해, 
1) `도착한 패킷# == i` => `i++`
2) `도착한 패킷# != i` => 패킷 폐기

ACK #0 이면 #1패킷을 기다리고, 먼저 도착한 #2, #3은 버린다.   

**GBN 모델 예시**
![ㅁㄴㅇ](,,/../../../src/network3-45.PNG)

- Time Out이 발생한 #N로 window를 되돌려서 go-back-N
- window 안에 있는 애들은 아직 cumulative ACK를 받지 않았기 때문에 재전송을 대비해 buffer에 저장해야 한다.  

**장점**  
구조가 단순  
Reciver는 데이터를 폐기하기 때문에 버퍼가 필요 없음.  

**문제점**  
현실에서는 windowSize가 거대하다.  
손상/분실된 프레임 이후의 프레임을 모두 재전송하는 GBn ARQ는 windowSize만큼의 패킷 재전송이 빈번하게 일어난다.  


### Sective Repeat
문제가 발생한 패킷만 재전송한다.   
이를 위해서 버퍼가 필요하며, 각 패킷에 타이머가 있다.   
Receiver는 받은 패킷에 대한 ACK를 전송한다.    


**SR 모델 예시**
![ㅁㄴㅇ](,,/../../../src/network3-49.PNG)
패킷 2번이 Loss 나는 경우, 2~5에서 대기.   
0~5번 모두 ACK를 받고, 2번 패킷만 TimeOut 나는 경우,   
2번 재전송하고, 6,7,8,9 전송  

**장점**  
네트워크 부하가 적음  

**단점**
Receiver의 구조가 복잡해짐.  


**SR 모델의 딜레마 : Sequence 넘버를 몇으로 설정할 것인가?**  
RDT 3.0에서는 시퀀스 넘버가 0~1이었다.  
SR모델은 버퍼를 사용하기 때문에 (windowSize+1)보다 큰 시퀀스 넘버가 필요하다.   

얼마가 필요한가? 대~충..두 배 언저리?  