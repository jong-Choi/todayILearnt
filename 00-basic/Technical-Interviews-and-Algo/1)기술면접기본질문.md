https://dkanxmstmdgml.tistory.com/716 참고
https://covenant.tistory.com/163 참고

## 1~10번 안내

Q1에서 Q10 까지는 컴퓨팅 및 컴퓨터 과학, 인터넷 등의 기본적인 개념에 대한 영어 위키백과의 설명이다. 각 빈칸을 채워 넣으시오. (문항당 정답은 한 개이며, 단복 수형의 구분 무관 및 영문이 아닌 한국어로 번역된 명칭을 적어도 무방함.)

### 1번

In computer science, a ( ) of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system. The implementation of ( ) and processes differs between operating systems, but in most cases a ( ) is a component of a process. Multiple ( ) can exist within one process, executing concurrently and sharing resources such as memory, while different processes do not share these resources. [3 점]

답. 쓰레드(Thread)
해설. Multiple ( ) can exist within one process. 에서 쓰레드라고 확실하게 생각할 수 있습니다.

#### 프로세스와 스레드

(https://thebook.io/006950/ch10/)

##### 프로세스

프로그램 : 하드디스크에 저장된 실행 파일.  
프로세스 : 실행중인 프로그램. 즉, 하드디스크에서 메인메모리로 로드되어 작동중인 상태. 하나의 프로그램을 두 번 실행하면 두 개의 프로세스가 생성된다.

###### 프로세스의 상태

Created : 생성 상태. 프로세스를 더블클릭하였을 때에 실행 가능 상태로 진입하는 상태. 곧바로 실행되는 것이 아니라 실행중인 프로세스와 우선순위를 비교하며 실행 가능 상태에서 대기.
Waiting : 실행 가능 상태. CPU는 인터럽트 발생 시 실행중인 프로세스와 실행가능 프로세스의 우선순위에 따라 프로세스를 교체한다. 실행 가능상태에서 CPU를 할당받아 실행 상태로 변경되는 것을 디스패치dispatch, 운영체제가 실행중이던 프로세스에서 CPU를 해제하는 것을 프리엠션preemption
Running : 실행 상태. 운영체제로부터 CPU를 할당받아 실행되고 있는 상태.
Blocked : 프로세스가 I/O작업을 하는 경우 CPU를 해제하고 보류상태가 된다. I/O작업이 끝나면 Waiting상태로 변경된다.
Terminated : 프로세스 실행이 완료되어 메인 메모리에서 사라지는 상태.

###### 스케쥴링

preemptive scheduling(선점형 : 다른 프로세스가 실행중인 프로세스의 CPU를 빼앗아 차지할 수 있음), non-preemptive scheduling(비선점형 : 특정한 프로세스의 작업이 끝날 때 가지 '독점'하는 방법.)

##### 스레드

프로세스가 실행 흐름이라면, 스레드는 프로세스보다 작은, 실행 흐름의 최소 단위
스레드는 인스트럭션의 나열이다.  
프로레스가 각각의 PCB를 할당받고 완벽히 독립적이라면, 스레드는 각각의 스레드가 독립적인 스택을 갖지만, 코드영역과 데이터영역은 하나를 공유한다.  
각각의 스레드는 라운드 로빈과 비슷하게 일정한 타임 슬라이스를 바탕으로 CPU를 할당받는다.

###### 경쟁 조건과 상호 배제

라운드 로빈 등의 선점형 스케줄링에서는 '공유데이터를 가져오고', 처리하는 중에 blocked되어 다른 스레드에서 해당 공유데이터를 조작할 수 있다. 이와 같은 경우 원하는 결과가 안나올 것이다. 이와 같이 선점형 스케줄링을 여러개의 스레드가 동시에 접근할 수 있는 상황을 경쟁조건이라 부르며, 특정 스레드가 공유 데이터를 이용하는 동안 다른 스레드의 접근을 막는 것을 상호 배제라 부른다.

### 2번

In multitasking computer operating systems, a ( ) is a computer program that runs as a background process, rather than being under the direct control of an interactive user. Traditionally, the process names of a ( ) end with the letter d, for clarification that the process is, in fact, a ( ), and for differentiation between a ( ) and a normal computer program. For example, syslogd is the ( ) that implements the system logging facility, and sshd is a ( ) that serves incoming SSH connections. [5 점]

답. 데몬(Daemon)
해설. the process names of a ( ) end with the letter d. 라는 표현을 보고 D로 시작한다는 힌트를 얻을 수 있습니다. 첫 문장 a ( ) is a computer program that runs as a background process을 보면 데몬이라고 확신할 수 있습니다.

### 3번

In computer science, a ( ) is a type of resource leak that occurs when a computer program incorrectly manages memory allocations in such a way that memory which is no longer needed is not released. [3 점]

답. Memory leak(메모리 누수)

해설. 문제에 답이 쓰여있습니다.. 포인터가 여전히 해제된 메모리 영역을 가리키고 있는 댕글링 포인터(Dangling Pointer)에 대해서도 추가적으로 알아두세요.

#### 메모리

##### 메모리 계층

레지스터, 캐시, 메모리(주기억장치), 저장장치(보조기억장치) 로 구성되어 있다.

캐싱은 느린 저장장치에서 빠른 저장장치로 데이터를 미리 복사해놓는 것이며, 저장장치는 메모리로, 메모리는 캐시로, 캐시는 레지스터로 캐싱하며, CPU의 빠른 속도와 저장장치의 느린 속도 차이를 극복하기 위해 사용된다.

캐싱의 지역성의 원리 : 시간 지역성 - for문 등에서 최근에 접근한 인덱스는 다시 접근할 가능성이 높아 캐싱함. 공간 지역성 - 배열 등에서 인접한 데이터들은 다시 접근할 가능성이 높음. 3번 인덱스에 접근했다면 인접한 인덱스들을 메모리에 캐싱함.

웹 브라우저의 캐시 :  
쿠키 - 만료 기한이 있는 키-값  
로컬 스토리지 - html5에서 만료 기한이 없는 키-값. 10mb. 도메인 단위로 유지됨.
세션 스토리지 - html5에서 만료 기한이 없는 키-값. 5mb. 탭 단위로 저장되며 탭을 종료하면 사라짐.

### 4번

In computing, ( ) is a computer program that takes one or more object files generated by a compiler and combines them into a single executable file, library file, or another 'object' file. A simpler version that writes its output directly to memory is called the loader, though loading is typically considered a separate process. [3 점]

답. 링커(Linker)

Source. https://jsommers.github.io/cbook/programstructure

해설. 컴파일러로부터 생성된 오브젝트 파일에 라이브러리 파일, 다른 오브젝트 파일을 합친다(combines) 표현에서 링커라고 알 수 있습니다.

### 5번

The ( ) is a hierarchical decentralized naming system for computers, services, or other resources connected to the Internet or a private network. It associates various information with domain names assigned to each of the participating entities. Most prominently, it translates more readily memorized domain names to the numerical IP addresses needed for locating and identifying computer services and devices with the underlying network protocols. By providing a worldwide, distributed directory service, the ( ) is an essential component of the functionality on the Internet, that has been in use since 1985. [3 점]

답. 도메인 네임 시스템(DNS, Domain Name System)
해설. 처음 읽으면 긴가민가 할 수 있는데 it translates more readily memorized domain names to the numerical IP addresses ~~ 부분을 보고 DNS라고 확신할 수 있습니다.

### 6번

( ) uses a simple connectionless communication model with a minimum of protocol mechanism. ( ) provides checksums for data integrity, and port numbers for addressing different functions at the source and destination of the datagram. It has no handshaking dialogues, and thus exposes the user's program to any unreliability of the underlying network; There is no g uarantee of delivery, ordering, or duplicate protection. If errorcorrection facilities are needed at the network interface level, an application may use the Transmission Control Protocol (TCP) or Stream Control Transmission Protocol (SCTP) which are designed for this purpose. [5 점]

답. UDP

해설. connectionless, no handshaking dialogues, unreliability, no guarantee of delivery 이러한 키워드가 UDP에 대한 설명입니다. 또한 마지막에 반대되는 성격의 TCP가 나오는 것으로 UDP라고 확신할 수 있습니다.

### 7번

( ) is a set of Web development techniques using many Web technologies on the client side to create asynchronous Web applications. With ( ), Web applications can send data to and retrieve from a server asynchronously (in the background) without interfering with the display and behavior of the existing page. By decoupling the data interchange layer from the presentation layer, ( ) allows for Web pages, and by extension Web applications, to change content dynamically without the need to reload the entire page. In practice, modern implementations commonly substitute JSON for XML due to the advantages of being native to JavaScript. [5 점]

답. AJAX

해설. 첫 줄에 클라이언트에서 비동기적 기술, 그리고 다시 불러오지 않고 동적으로 변화된 점을 보여준다는 점에서 Ajax라고 할 수 있습니다.

### 8번

A ( ) in the C programming language (and many derivatives) is a composite data type declaration that defines a physically grouped list of variables to be placed under one name in a block of memory, allowing the different variables to be accessed via a single pointer, or the ( ) declared name which returns the same address. In the C++ language, a ( ) is identical to a C++ class but a difference in the default visibility exists: class members are by default private, whereas ( ) members are by default public. [5 점]

답. 구조체(struct)

해설. 첫째 줄에 C 문법에서 변수들을 그룹으로 묶어서 하나의 메모리 블록에 저장되는 특징. C++의 class와 다르게 public으로 접근 가능한다는 특징은 struct입니다.

### 9번

In object-oriented programming, ( ) is when an object or class is based on another object (prototypal ( )) or class (class-based ( )), using the same implementation. ( ) in most classbased object oriented languages is a mechanism in which one object acquires all the properties and behaviors of parent object. [5 점]

답. 상속(Inheritance)

해설. 처음에 based on another object 표현. 마지막 줄, 부모 오브젝트의 모든 properties와 behavior를 얻을 수 있다는 점에서 답은 상속입니다.

### 10번

A ( ) symbolizes a unit of work performed within a database management system (or similar system) against a database, and treated in a coherent and reliable way independent of other ( ). A ( ) generally represents any change in a database. ( ) in a database environment have two main purposes: [5 점]

To provide reliable units of work that allow correct recovery from failures and keep a database consistent even in cases of system failure, when execution stops (completely or partially) and many
operations upon a database remain uncompleted, with unclear status.
To provide isolation between programs accessing a database concurrently. If this isolation is not provided, the programs' outcomes are possibly erroneous.

답. Transaction(트렌잭션)

해설. A ( ) symbolizes a unit of work performed within a database management system.을 보고 트렌잭션이라고 알 수 있습니다. 다음에 나오는 긴 내용은 트랜젝션의 ACID(원자성, 일관성, 고립성, 지속성)에 대한 설명입니다. 해당 내용이 기억이 나지 않으시면 데이터베이스 트랜젝션 ACID란? 글을 확인해 주세요.

## 객관식

### 11번

아래는 TCP 의 커넥션 종료 과정을 도식화한 그림이다. 빈 칸의 상태에 알맞는 번호를 각각 기입하시오. [10 점]

1. CLOSE_WAIT
2. TIME_WAIT
3. FIN_WAIT_1
4. FIN_WAIT_2
   The connection termination phase uses a four-way handshake, with each side of the connection terminating independently. When an endpoint wishes to stop its half of the connection, it transmits a FIN packet, which the other end acknowledges with an ACK. Therefore, a typical tear-down requires a pair of FIN and ACK segments from each TCP endpoint. After the side that sent the first FIN has responded with the final ACK, it waits for a timeout before finally closing the connection, during which time the local port is unavailable for new connections; this prevents confusion due to delayed packets being delivered during subsequent connections.

답. 위에서 아래로 순서대로

3. FIN_WAIT_1
1. CLOSE_WAIT
1. FIN_WAIT_2
1. TIME_WAIT
   위의 영문 지문이 크게 도움 안 되는 문제입니다.. 관련 내용을 알고 있지 않으면 틀릴 수밖에 없습니다.

### 12번

다음은 Model–view–controller (MVC) 소프트웨어 디자인 패턴에 관한 설명 중 일부이다. 구성요소에 대한 설명 중 빈 칸에 알맞는 번호를 각각 기입하시오. [5 점]

1. Model
2. View
3. Controller

The ( ) accepts input and converts it to commands.
A ( ) can be any output representation of information, such as a chart or a diagram.
The ( ) is the central component of the pattern. It expresses the application's behavior in terms of the problem domain, independent of the user interface. It directly manages the data, logic and rules of the application.

정답 및 해설

Source. openclassrooms
Controller
Model과 view를 연결하는 역할을 합니다.
View
화면에 무엇인가를 보여주기 위한 역할입니다.
Model
어플리케이션이 무엇을 할지 결정합니다.
처리되는 알고리즘, DB 데이터 등등이 해당됩니다.

### 13번

아래 코드의 시간 복잡도는 어떻게 되는가? [5 점]

int f(int n) {
if (n <= 1) {
return 1;
}
return f(n - 1) + f(n - 1);
}

1. Ο(1)
2. Ο(𝑛)
3. Ο(𝑛 log 𝑛)
4. Ο(𝑛^2)
5. Ο(2^𝑛)

답. 5. Ο(2^𝑛)

해설.

알고리즘 수업을 들으면 시간 복잡도를 계산하는 문제에서 가장 기본 문제로 나오는 코드입니다. 위와 같이 재귀 트리(Recursion Tree)를 풀면 Ο(2^𝑛)으로 증가하는 것을 알 수 있습니다.

### 14번

아래 코드의 시간 복잡도는 어떻게 되는가? [5 점]

int f(int n) {
int sum = 0;
for (int i = 0; i < n; i++) {
for (int j = 0; j < n / 2; j++) {
sum \*= j;
}
}

return sum;
}

1. Ο(1)
2. Ο(𝑛)
3. Ο(𝑛 log 𝑛)
4. Ο(𝑛^2)
5. Ο(2^𝑛)

답. 4. Ο(𝑛^2)
해설. n에 대해서 2중 for문이기 때문에 Ο(𝑛^2)입니다.

### 15번

아래는 Queue 로 구현한 Stack 클래스의 자바 코드이다.

public class Stack {
private Queue Q = new Queue();

    public E pop() {
        int k = 1;
        while(k++ < Q.size())
            Q.enqueue(Q.dequeue());
            return Q.dequeue();
    }

    public void push(E o){
        Q.enqueue(o);
    }

}
Queue 의 enqueue(o)와 dequeue()의 시간복잡도가 Ο(1) 일때 Stack 클래스의 push(o)와 pop() 각각의 시간 복잡도를 기입하시오. [7 점]

push(o): 𝚶( )
pop(): 𝚶( )

답

push(o): 𝚶(1)
push 안의 메서드인 enqueue는 𝚶(1)로 수행됩니다.
pop(): 𝚶(n)
while이 Queue 크기만큼 dequeue, enqueue를 수행하기 때문입니다.

### 16번

중복된 원소가 없는 서로 길이가 다른 숫자 리스트 A, B 가 있다. 두 리스트 내에 공통으로 포함된 원소를 출력하고자 한다. 두 리스트 중 한 개를 정렬하고, 다른 리스트를 순회하면서 이진 검색 Binary Search 으로 포함 여부를 체크한다고 할때 어떤 리스트를 정렬하는게 더 빠를지 고르시오. 단, len(A) < len(B) 이며 정렬은 병합 정렬 Merge Sort 을 사용하여 Ο(𝑛 log 𝑛)의 시간 복잡도로 진행한다. [5 점]

1. 길이가 짧은 A
2. 길이가 긴 B
3. 상관 없음

답. (1) 길이가 짧은 A

해설.
len(A)=a, len(B)=b라고 정의한다면 다음과 같이 각각의 경우 시간 복잡도를 구할 수 있습니다.

[A를 정렬하는 경우]

a를 정렬하면 alog(a) 시간이 걸립니다. 각각의 b에 대해서 log(a) (∵ a에 대해서 이진검색을 하므로)의 탐색을 합니다. 따라서 alog(a) + blog(a) = (a+b)log(a)

[B를 정렬하는 경우]

b를 정렬하면 blog(b) 시간이 걸립니다. 각각의 a에 대해서 log(b) (∵ b에 대해서 이진검색을 하므로)의 시간이 걸립니다. 따라서 blog(b) + alog(b) = (a+b)log(b)

(a+b)loga < (a+b)logb 입니다. 여기서 a < b 이므로 답은 1번이 됩니다.

### 17번

웹 브라우저의 이전페이지로 돌아가기와 에디터의 되돌리기 Undo 기능을 구현하기에 적합한 자료구조는? [3 점]

1. Hash
2. Stack
3. Queue
4. Tree
5. Graph

답. 2(Stack)
해설. 웹 페이지의 이전페이지로 돌아가는 것, 에디터에서 되돌리는 기능의 공통점은 가장 최근에 실행한 것으로 되돌아가야 하는 것입니다. LIFO 자료구조인 스택을 사용해야 합니다.

### 18번

DB 의 인덱스 Index 는 원하는 레코드 Record 에 빠르게 접근 할 수 있게 해준다. 문자열과 숫자 컬럼에 대한 인덱스를 구현할 때 사용할 수 있는 자료구조를 모두 고르시오. [5 점]

1. Hash
2. Stack
3. Queue
4. Tree
5. Graph

답. 1(Hash), 4(Tree)

해설. DB는 특징이 하나의 테이블에 정렬되지 않은 자료가 선형으로 저장되어 있습니다. 선형 자료를 빠르게 탐색하기 위해서는 해시, 트리, 정렬되어 있다면 이분탐색이 가능합니다. 스택 은 중간의 자료를 탐색하는데 최악의 경우 시간복잡도는 O(n)이기에 부적합합니다. 그래프는 cycle 관계의 데이터를 관리하는데 유용합니다.

### 19번

새로 가입하는 사용자에게 메일을 보내야 하는데, 실제 가입까지 처리는 10 𝑚𝑠 밖에 걸리지 않지만, 메일을 보내는 시간은 1000 𝑚𝑠 가 소요된다. 이런 경우에 가입자에게 메일을 순차적으로 발송하는 시스템을 구현하기 위한 자료구조로 적합한 것은? [3 점]

1. Hash
2. Stack
3. Queue
4. Tree
5. Graph

답. 3(Queue)

해설. 가입한 사람 순으로 발송하는 메일 시스템을 구현해야 합니다. 문제는 가입 시간보다 발송하는데 오래 걸립니다. 그렇기 때문에 버퍼에 저장을 해야 하며, 먼저 들어온 데이터가 먼저 처리되는 FIFO 자료구조인 큐를 사용해야 합니다.

### 20번

트리의 순회 방법 Tree traversal 에는 현재 노드를 언제 순회하느냐에 따라 전위 순회 Pre-order, 중위 순회 In-order, 후위 순회 Post-order 가 있다.

전위 순회는 현재 노드를 방문 후 왼쪽 서브 트리, 오른쪽 서브 트리 순으로 전위 순회를 한다.
중위 순회는 왼쪽 서브 트리를 중위 순회한 후 현재 노드를 방문하고, 마지막으로 오른쪽 서브 트리를 중위 순회한다.
후위 순회는 왼쪽 서브 트리, 오른쪽 서브 트리 순으로 후위 순회한 후, 마지막으로 현재 노드를 방문한다.

예를 들어, 위와 같은 이진트리가 주어졌을 때 각각의 순회 결과는 다음과 같다.

전위 순회 : 1 2 4 5 3

중위 순회 : 4 2 5 1 3
후위 순회 : 4 5 2 3 1

이진 탐색 트리의 전위 순회, 중위 순회 결과가 다음과 같을 때,

전위 순회: F, B, A, D, C, E, G, I, H
중위 순회: A, B, C, D, E, F, G, H, I
후위 순회 결과를 나열하시오. [10 점]

정답: A, ( ), E, ( ), ( ), H, ( ), G, ( )

답

A, (C), E, (D), (B), H, (I), G, (F)

해설

친절하게 예시를 주었기 때문에 이에 맞추어 직접 해보면 됩니다.


### 데이터 베이스
데이터 베이스는 일정한 규칙에 따라 구조화되어 저장되는 데이터의 모음이다.  
데이터 베이스는 실시간 접근 및 공시 공유가 가능하다.  

- 엔터티
엔터티는 사람, 장소, 물건, 사건, 개념 등 여러개의 속성을 지닌 명사를 의미한다.  
엔터티의 속성은 서비스에 따라 달라진다. 

엔터티는 종속관계에 따라 강한 엔터티, 약한 엔터티로 나뉠 수 있다. (집(강한 엔터티)이 없으면 방(약한 엔터티)이 존재할 수 없다.)

회원 엔터티는 이름, 성별, 이메일 주소, 전화번호 등의 속성을 가질 수 있으며, 서비스에 따라 달라진다.  


- 릴레이션
데이터 베이스에 정보를 저장하는 기본 단위.

회원은 이름 ,아이디, 주소, 전화번호의 레코드명을 가지게된다.

이러한 릴레이션을 '테이블', 혹은 '컬렉션'이라 부른다.
여러개의 테이블로 이루어진 것이 데이터베이스 이다.

MySQL은 레코드-테이블-데이터베이스 구조, 몽고DB는 도큐먼드-컬렉션-데이터베이스


- 속성 : 릴레이션에서 관리하는 구체적인 이름을 가진 정보
- 도메인 : 릴레이션에서 속성을 가질 수 있는 값의 집합. 가녕 성별 어트리뷰트는 {남, 여}라는 도메인


'회원'이라는 '엔터티'를 정의하고,
이를 아래와 같은 '테이블'로 만들었다.

| name | id | address |
|---|---|---|
| 큰돌 | kundol | 서울 |
| 민수 | strongminsu | 나이지리아 |

- 필드 : 각 열(칼럼) 단위. 제일 위에 있는 행이 필드명이 된다. name, id, address 등
- 레코드 : 테이블에 쌓이는 행(로우) 단위의 데이터.  
- 필드 타입 : 숫자(TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT), 날짜(DATE, DATETIME), 글자(TIMESTAMP, CHAR, VARCHAR / TEXT, BLOB / ENUM, SET)

- 슈퍼키 : 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키.

- 기본키(PK) 
- 후보키 : 기본키가 될 수 있는 키들. 유일성 + 최소성.
- 대체키 : 후보키이지만 기본키가 되지 못한 것

기본키의 종류 : 자연키 - 중복되는 값들을 제거하고 자연스럽게 나오는 키. 주민등록번호. 중복된 값이 언젠가는 발생하여 자연키가 변할 수 있음, 인조키 - 변하지 않음. 유저아이디. 대부분의 데이터베이스에서 사용.

- 외래키(FK): 다른 테이블의 기본키를 그대로 참조하는 값. 개체와의 관계 식별에 사용.


#### ERD(Entity Relationship Diagram)
고려할 사항
1. 1:1 관계인지, 1:N 관계인지, N:M관계인지.
2. 비어있을 수 있는지, 혹은 반드시 1개 이상 포함되어야 하는지.


#### 정규화
- 제 1 정규형 : 모든 도메인은 분해될 수 없는 원자값으로 구성되어야 함. [언어 : {파이썬, 자바스크립트}]가 아니라 [언어: 파이썬], [언어 : 자바스크립트]
- 제 2 정규형 : 부분 함수의 종속성 제거. 모든 값은 기본키를 기준으로 완전 함수 종속적이어야 한다. 가령 '유저번호' / '이름' / '수강목록' / '수강생 과목별 성취도'가 있다면 '유저번호'/'이름', '이름'/'수강목록'/'수강생 과목별 성취도'의 두 개의 릴레이션으로 분해한다.  
- 제 3 정규형 : 고객정보 - 고객별 등급 - 등급별 할인율이 있을 때에, 고객별 할인율은 고객정보-고객별등급-등급별 할인율을 조회해서 알 수 있다. 이를 이행적 함수 종속이라 한다. '고객정보 - 고객별 등급', '고객별 등급 - 등급별 할인율' 두 개의 테이블로 나눠서 관리함이 적절하다.  

정규화를 위해 테이블을 나누면 퀴리가 늘어나 성능이 저하될 수 있다. 서비스에 따라 비정규화가 필요하다.  


### 트랜잭션
하나의 논리 기능을 수행하기 위한 작업 단위. 여러 쿼리로 이루어진다. 
트랜잭션 단위로 커밋과 롤백을 진행하며 데이터의 무결성을 보장할 수 있다. 
- 원자성 : All or Nothing. 중간 과정 따위는 중요하지 않다. 성공 혹은 실패. 
커밋과 롤백 - 여러 쿼리들이 성공적으로 처리되어 트랜잭션을 커밋. 복구 역시 커밋 단위로 롤백. 
트랜잭션 전파 - 트랜잭션은 커넥션( DB와 애플리케이션 간 통신을 할 수 있는 수단 ) 단위로 이루어 진다. 이를 간편하게 하기 위해 여러 관련 쿼리들을 하나의 트랜젝션으로 묶어서 처리하는 것을 트랜잭션 전파라 한다.

일관성 - 허용된 방식으로만 데이터를 변경할 수 있는 것.
격리성 - 트랜잭션 수행 시 서로 끼어들이 못하도록. 
지속성 - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함. 지속성을 유지하기 위해 체크섬(오류 정정, 무결성 보호), 저널링(커밋 전에 로그를 남기는 것.) 등의 기능 제공

#### 격리 수준
격리성이 지켜지지 않으면 아래와 같은 문제 발생 팬텀리드(조회할 때마다 결과(행 갯수 등)이 다름), 반복 가능하지 않은 조회(조회할 때 마다 행의 값 다름), 더티 리드(커밋되지 않은 행을 읽을 수 있음)

격리수준 : 
시리얼라이저블 - 트랜잭션을 순차적으로 진행
REPEATABLE_READ - 수정은 불가능. 추가는 가능.
READ_COMMITTED - 가장 많이 사용되는 수준. 커밋하지 않은 정보는 읽을 수 없음. 수정 가능.
READ_UNCOMMITED - 속도가 가장 빠름. 빅데이터를 어림잡아 사용할 때.

### 무결성
데이터의 정확성, 일관성, 유효성을 유지하는 것.
개체 무결성
참조 무결성
고유 무결성
NULL 무결성


### 데이터 베이스의 종류
RDBMS : 행과 열의 표 형식으로 데이터를 저장하는 데이터 베이스. 
NoSQL : Not only SQL. SQL을 사용하지 않으며 MongoDB는 JSON을 사용한다.  

## 인덱스
B트리 구조 : 루트 노드를 모아둔 테이블을 조회한 후 해당 루느토드를 기준으로 리프노드를 찾아 간다. 조회 횟수를 줄일 수 있다. 

숫자를 찾아보자. (57보다 같거나 클 때까지)
루트 노드 배열에서 57보다 큰 수를 만나면 그의 자식 노드, 즉 브랜치 노드를 본다.
그 브랜치 노드에서 57보다 큰 수를 만나면 도 내러가고... 또 내려가고...그렇게 57이 찾아진다.  

대수 확장성 : 트리의 깊이가 리프 노드 수에 비해 매우 느리게 성장한다. 일반적으로 깊이가 하나 증가할 때에, 리프 노드는 4배 증가하며, 실제 인덱싱은 훨씬 더 효율이 좋다.  

### 인덱스 최적화
1. 인덱스는 비용이다. 인덱스는 두 번 조회할 것을 강요하고, 데이터를 분산시키고 트리의 높이를 조절하는 비용도 든다. 
2. 인덱스의 성능은 테스트하라. 
3. 인덱스가 우선될 수 있는 것은 '==연산', '정렬에 쓰이는 필드', '다중값', '카디널리티(희소한 정도)' 순으로 인덱싱의 우선순위를 갖는다.  

## 조인
두 개 이상의 테이블을 묶어서 하나로 묶는 것.

내부 조인 : 교집합
왼쪽 조인 : 왼쪽을 기준으로 해당되는 녀석들을 오른쪽에서 추가하기
오른쪽 조인 : 오른쪽을 기준으로 해당되는 녀석들을 왼쪽에서 추가하기
합집합 조인 : 합집합

### 조인의 원리
중첩 루프 조인 - 이중 포문으로 랜덤접근하며 사용. 대용량 데이터에는 사용 불가.  
정렬 병합 조인 - 정렬을 하고 나서 조인하기. 대용량 데이터, 비교연산할 때 유용
해시 조인 - 하나의 테이블이 온전히 메모리에 들어갈 수 있다면 동등 조인에서 사용. 

mySQL의 해시 조인 : 빌드 단계 - 바이트가 더 작은 테이블을 기반으로 테이블을 빌드한다. 프로브 단계 - 레코드를 읽기 시작하며 빌드 단계에서 만들어진 테이블과 일치하는 레코들을 결과값으로 반환.  즉 바이트가 작은 테이블 한 번, 바이트가 큰 테이블 한 번. 총 2번 읽는다.   